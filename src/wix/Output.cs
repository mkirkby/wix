//-------------------------------------------------------------------------------------------------
// <copyright file="Output.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
//    
//    The use and distribution terms for this software are covered by the
//    Common Public License 1.0 (http://opensource.org/licenses/cpl.php)
//    which can be found in the file CPL.TXT at the root of this distribution.
//    By using this software in any fashion, you are agreeing to be bound by
//    the terms of this license.
//    
//    You must not remove this notice, or any other, from this software.
// </copyright>
// 
// <summary>
// Output of linker before binding.
// </summary>
//-------------------------------------------------------------------------------------------------

namespace Microsoft.Tools.WindowsInstallerXml
{
    using System;
    using System.Diagnostics;
    using System.Globalization;
    using System.Xml;

    /// <summary>
    /// Various types of output.
    /// </summary>
    public enum OutputType
    {
        /// <summary>Unknown output type.</summary>
        Unknown,
        /// <summary>Module output type.</summary>
        Module,
        /// <summary>Product output type.</summary>
        Product,
        /// <summary>Patch Creation output type.</summary>
        PatchCreation
    }

    /// <summary>
    /// Output is generated by the linker.
    /// </summary>
    public class Output
    {
        private string path;

        private Section entrySection;
        private OutputType type;
        private int codepage;
        private bool compressed;
        private bool longFileNames;
        private string moduleGuid;

        private SectionCollection sections;
        private ConnectToFeatureCollection componentsToFeatures;
        private ConnectToFeatureCollection modulesToFeatures;
        private ConnectToFeatureCollection featuresToFeatures;
        private IgnoreModularizationCollection ignoreModularizations;

        private OutputTableCollection outputTables;
        private ImportStreamCollection importStreams;
        private RowCollection modules;
        private FileMediaInformationCollection fileMediaInfoCollection;
        private MediaRowCollection mediaRows;
        private bool suppressAdminSequence;
        private bool suppressAdvertiseSequence;
        private bool suppressUISequence;

        /// <summary>
        /// Creates a new empty output object.
        /// </summary>
        internal Output()
        {
            this.componentsToFeatures = new ConnectToFeatureCollection();
            this.modulesToFeatures = new ConnectToFeatureCollection();
            this.featuresToFeatures = new ConnectToFeatureCollection();
            this.ignoreModularizations = new IgnoreModularizationCollection();

            this.outputTables = new OutputTableCollection();
            this.importStreams = new ImportStreamCollection();
            this.modules = new RowCollection();
            this.fileMediaInfoCollection = new FileMediaInformationCollection();
            this.mediaRows = new MediaRowCollection();
            this.suppressAdminSequence = false;
            this.suppressAdvertiseSequence = false;
            this.suppressUISequence = false;
        }

        /// <summary>
        /// Creates a new output object with the specified entry section.
        /// </summary>
        /// <param name="entrySection">Entry section for the output.</param>
        internal Output(Section entrySection) :
            this()
        {
            this.entrySection = entrySection;
            this.sections = new SectionCollection();
            this.codepage = entrySection.Codepage;

            switch (this.entrySection.Type)
            {
                case SectionType.Product:
                    this.type = OutputType.Product;
                    this.compressed = false;
                    break;
                case SectionType.Module:
                    this.type = OutputType.Module;
                    this.compressed = true;
                    break;
                case SectionType.PatchCreation:
                    this.type = OutputType.PatchCreation;
                    this.compressed = false;
                    break;
                default:
                    throw new ApplicationException(String.Format("Unexpected entry section type: {0}", this.entrySection.Type));
            }
        }

        /// <summary>
        /// Gets or sets the path to this output on disk.
        /// </summary>
        /// <value>Path to output on disk.</value>
        /// <remarks>The Path may be null if this output was never persisted to disk.</remarks>
        public string Path
        {
            get { return this.path; }
            set { this.path = value; }
        }

        /// <summary>
        /// Gets the entry section for the output
        /// </summary>
        /// <value>Entry section for the output.</value>
        public Section EntrySection
        {
            get { return this.entrySection; }
        }

        /// <summary>
        /// Gets the type of the output.
        /// </summary>
        /// <value>Type of the output.</value>
        public OutputType Type
        {
            get { return this.type; }
        }

        /// <summary>
        /// Gets or sets the codepage for this output.
        /// </summary>
        /// <value>Codepage of the output.</value>
        public int Codepage
        {
            get { return this.codepage; }
            set { this.codepage = value; }
        }

        /// <summary>
        /// Gets or sets the compressed flag for this output.
        /// </summary>
        /// <value>Compressed flag of the output.</value>
        public bool Compressed
        {
            get { return this.compressed; }
            set { this.compressed = value; }
        }

        /// <summary>
        /// Gets or sets the long file names flag for this output.
        /// </summary>
        /// <value>Long file names flag of the output.</value>
        public bool LongFileNames
        {
            get { return this.longFileNames; }
            set { this.longFileNames = value; }
        }

        /// <summary>
        /// Gets or sets the guid used by modularization.
        /// </summary>
        /// <value>Modularization guid.</value>
        public string ModularizationGuid
        {
            get { return this.moduleGuid; }
            set { this.moduleGuid = value; }
        }

        /// <summary>
        /// Gets the sections contained in the output.
        /// </summary>
        /// <value>Sections in the output.</value>
        public SectionCollection Sections
        {
            get { return this.sections; }
        }

        /// <summary>
        /// Gets the Modules to Features map.
        /// </summary>
        /// <value>Modules to Features map.</value>
        public ConnectToFeatureCollection ModulesToFeatures
        {
            get { return this.modulesToFeatures; }
        }

        /// <summary>
        /// Gets the collection of values to ignore modulatization
        /// </summary>
        /// <value>Collection of values to ignore modularization.</value>
        public IgnoreModularizationCollection IgnoreModularizations
        {
            get { return this.ignoreModularizations; }
        }

        /// <summary>
        /// Gets the tables contained in this ouput.
        /// </summary>
        /// <value>Collection of tables.</value>
        public OutputTableCollection OutputTables
        {
            get { return this.outputTables; }
        }

        /// <summary>
        /// Gets the collection of streams to import into the final output.
        /// </summary>
        /// <value>Streams to import.</value>
        public ImportStreamCollection ImportStreams
        {
            get { return this.importStreams; }
        }

        /// <summary>
        /// Gets the collection of Merge records.
        /// </summary>
        /// <value>Merge rows to merge.</value>
        public RowCollection Modules
        {
            get { return this.modules; }
        }

        /// <summary>
        /// Gets the information about all the files and their media layout.
        /// </summary>
        /// <value>Collection of file/media information.</value>
        public FileMediaInformationCollection FileMediaInformationCollection
        {
            get { return this.fileMediaInfoCollection; }
        }

        /// <summary>
        /// Gets the collection of Media records.
        /// </summary>
        /// <value>Media records for final output.</value>
        public MediaRowCollection MediaRows
        {
            get { return this.mediaRows; }
        }

        /// <summary>
        /// Gets or sets the option to suppress admin sequence actions.
        /// </summary>
        /// <value>The option to suppress admin sequence actions.</value>
        public bool SuppressAdminSequence
        {
            set { this.suppressAdminSequence = value; }
            get { return this.suppressAdminSequence; }
        }

        /// <summary>
        /// Gets or sets the option to suppress advertise sequence actions.
        /// </summary>
        /// <value>The option to suppress admin advertise actions.</value>
        public bool SuppressAdvertiseSequence
        {
            set { this.suppressAdvertiseSequence = value; }
            get { return this.suppressAdvertiseSequence; }
        }

        /// <summary>
        /// Gets or sets the option to suppress UI sequence actions.
        /// </summary>
        /// <value>The option to suppress UI sequence actions.</value>
        public bool SuppressUISequence
        {
            set { this.suppressUISequence = value; }
            get { return this.suppressUISequence; }
        }

        /// <summary>
        /// Loads an output from a path on disk.
        /// </summary>
        /// <param name="path">Path to output file saved on disk.</param>
        /// <param name="suppressVersionCheck">Suppresses wix.dll version mismatch check.</param>
        /// <remarks>This method will set the Path property to the appropriate values on successful load.</remarks>
        /// <returns>Output object.</returns>
        public static Output Load(string path, bool suppressVersionCheck)
        {
            XmlTextReader reader = null;

            try
            {
                reader = new XmlTextReader(path);

                reader.MoveToContent();

                if ("wixOutput" != reader.LocalName)
                {
                    throw new WixParseException(String.Format("The xml document element was expected to be tableDefinitions, but was actually {0}.", reader.Name));
                }

                Output output = Parse(reader, suppressVersionCheck, path);

                return output;
            }
            catch (XmlException xe)
            {
                throw new WixInvalidOutputException(SourceLineNumberCollection.FromFileName(path), xe.Message);
            }
            catch (WixException we)
            {
                throw new WixInvalidOutputException(SourceLineNumberCollection.FromFileName(path), we.Message);
            }
            catch (FormatException fe)
            {
                throw new WixInvalidOutputException(SourceLineNumberCollection.FromFileName(path), fe.Message);
            }
            catch (OverflowException oe)
            {
                throw new WixInvalidOutputException(SourceLineNumberCollection.FromFileName(path), oe.Message);
            }
            finally
            {
                if (null != reader)
                {
                    reader.Close();
                }
            }
        }

        /// <summary>
        /// Saves an output to a path on disk.
        /// </summary>
        /// <param name="path">Path to save output file to disk.</param>
        /// <remarks>This method will set the Path property to the passed in value before saving.</remarks>
        public void Save(string path)
        {
            this.path = path;
            this.Save();
        }

        /// <summary>
        /// Saves an output to a path on disk.
        /// </summary>
        /// <remarks>This method will save the output to the file specified in the Path property.</remarks>
        public void Save()
        {
            XmlWriter writer = null;
            try
            {
                writer = new XmlTextWriter(this.path, System.Text.Encoding.UTF8);
                this.Persist(writer);
            }
            finally
            {
                if (null != writer)
                {
                    writer.Close();
                }
            }
        }

        /// <summary>
        /// Persists an output in an XML format.
        /// </summary>
        /// <param name="writer">XmlWriter where the Output should persist itself as XML.</param>
        internal void Persist(XmlWriter writer)
        {
            writer.WriteStartDocument();
            writer.WriteStartElement("wixOutput");
            writer.WriteAttributeString("xmlns", "http://schemas.microsoft.com/wix/2003/04/output");
            writer.WriteAttributeString("output", this.path);
            writer.WriteAttributeString("type", this.type.ToString());
            writer.WriteAttributeString("entrySectionId", this.entrySection.Id);
            if (0 != this.codepage)
            {
                writer.WriteAttributeString("codepage", this.codepage.ToString());
            }
            if (this.compressed)
            {
                writer.WriteAttributeString("compressed", "yes");
            }
            if (this.longFileNames)
            {
                writer.WriteAttributeString("longFileNames", "yes");
            }
            if (null != this.moduleGuid && 0 != this.moduleGuid.Length)
            {
                writer.WriteAttributeString("moduleGuid", this.moduleGuid);
            }
            if (this.suppressAdminSequence)
            {
                writer.WriteAttributeString("suppressAdminSequence", "yes");
            }
            if (this.suppressAdvertiseSequence)
            {
                writer.WriteAttributeString("suppressAdvertiseSequence", "yes");
            }
            if (this.suppressUISequence)
            {
                writer.WriteAttributeString("suppressUISequence", "yes");
            }

            Version currentVersion = Common.OutputFormatVersion;
            writer.WriteAttributeString("version", currentVersion.ToString());

            foreach (OutputTable outputTable in this.outputTables)
            {
                outputTable.Persist(writer);
            }

            foreach (ImportStream importStream in this.importStreams)
            {
                importStream.Persist(writer);
            }

            if (0 < this.componentsToFeatures.Count)
            {
                writer.WriteStartElement("componentsToFeatures");
                foreach (ConnectToFeature ctf in this.componentsToFeatures)
                {
                    ctf.Persist(writer);
                }
                writer.WriteEndElement();
            }

            if (0 < this.modulesToFeatures.Count)
            {
                writer.WriteStartElement("modulesToFeatures");
                foreach (ConnectToFeature ctf in this.modulesToFeatures)
                {
                    ctf.Persist(writer);
                }
                writer.WriteEndElement();
            }

            if (0 < this.featuresToFeatures.Count)
            {
                writer.WriteStartElement("featuresToFeatures");
                foreach (ConnectToFeature ctf in this.featuresToFeatures)
                {
                    ctf.Persist(writer);
                }
                writer.WriteEndElement();
            }

            if (0 < this.modules.Count)
            {
                writer.WriteStartElement("merge");
                this.outputTables["Merge"].TableDefinition.Persist(writer);
                foreach (MergeRow row in this.modules)
                {
                    row.Persist(writer);
                }
                writer.WriteEndElement();
            }

            foreach (FileMediaInformation fmi in this.fileMediaInfoCollection)
            {
                fmi.Persist(writer);
            }

            if (0 < this.mediaRows.Count)
            {
                writer.WriteStartElement("media");
                this.outputTables["Media"].TableDefinition.Persist(writer);
                foreach (MediaRow row in this.mediaRows)
                {
                    row.Persist(writer);
                }
                writer.WriteEndElement();
            }

            writer.WriteEndElement();
            writer.WriteEndDocument();
        }

        /// <summary>
        /// Processes an XmlReader and builds up the output object.
        /// </summary>
        /// <param name="reader">Reader to get data from.</param>
        /// <param name="suppressVersionCheck">Suppresses wix.dll version mismatch check.</param>
        /// <param name="path">The path to display in an error message.</param>
        /// <returns>The Output represented by the Xml.</returns>
        private static Output Parse(XmlReader reader, bool suppressVersionCheck, string path)
        {
            Debug.Assert("wixOutput" == reader.LocalName);

            Output output = new Output();
            output.path = path;
            string entrySectionId = null;
            SectionType sectionType = SectionType.Unknown;
            Version objVersion = null;
            bool empty = reader.IsEmptyElement;

            while (reader.MoveToNextAttribute())
            {
                switch (reader.LocalName)
                {
                    case "type":
                        switch (reader.Value)
                        {
                            case "Module":
                                output.type = OutputType.Module;
                                sectionType = SectionType.Module;
                                break;
                            case "Product":
                                output.type = OutputType.Product;
                                sectionType = SectionType.Product;
                                break;
                            case "PatchCreation":
                                output.type = OutputType.PatchCreation;
                                sectionType = SectionType.PatchCreation;
                                break;
                            default:
                                throw new WixParseException(String.Format("The wixOutput/@type attribute contains an unexpected value '{0}'.", reader.Value));
                        }
                        break;
                    case "codepage":
                        output.codepage = Convert.ToInt32(reader.Value, CultureInfo.InvariantCulture.NumberFormat);
                        break;
                    case "compressed":
                        output.compressed = Common.IsYes(reader.Value, null, "wixOutput", reader.Name, null);
                        break;
                    case "longFileNames":
                        output.longFileNames = Common.IsYes(reader.Value, null, "wixOutput", reader.Name, null);
                        break;
                    case "entrySectionId":
                        entrySectionId = reader.Value;
                        break;
                    case "moduleGuid":
                        output.moduleGuid = reader.Value;
                        break;
                    case "output":
                        output.path = reader.Value;
                        break;
                    case "suppressAdminSequence":
                        output.suppressAdminSequence = Common.IsYes(reader.Value, null, "wixOutput", reader.Name, null);
                        break;
                    case "suppressAdvertiseSequence":
                        output.suppressAdvertiseSequence = Common.IsYes(reader.Value, null, "wixOutput", reader.Name, null);
                        break;
                    case "suppressUISequence":
                        output.suppressUISequence = Common.IsYes(reader.Value, null, "wixOutput", reader.Name, null);
                        break;
                    case "version":
                        objVersion = new Version(reader.Value);
                        break;
                    case "xmlns":
                        break;
                    default:
                        throw new WixParseException(String.Format("The wixOutput element contains an unexpected attribute {0}.", reader.Name));
                }
            }
            if (null == entrySectionId)
            {
                throw new WixParseException("The wixOutput/@entrySectionId attribute was not found; it is required.");
            }
            if (null != objVersion && !suppressVersionCheck)
            {
                Version currentVersion = Common.OutputFormatVersion;
                if (0 != currentVersion.CompareTo(objVersion))
                {
                    throw new WixVersionMismatchException(currentVersion, objVersion, "Output", output.Path);
                }
            }

            // create a section for all the rows to belong to
            Intermediate intermediate = new Intermediate();
            output.entrySection = new Section(intermediate, entrySectionId, sectionType, output.codepage);

            // loop through the rest of the xml building up the Output object
            if (!empty)
            {
                bool done = false;

                // loop through all the fields in a row
                while (!done && reader.Read())
                {
                    switch (reader.NodeType)
                    {
                        case XmlNodeType.Element:
                            switch (reader.LocalName)
                            {
                                case "outputTable":
                                    output.outputTables.Add(OutputTable.Parse(reader, output.entrySection));
                                    break;
                                case "importStream":
                                    output.importStreams.Add(ImportStream.Parse(reader));
                                    break;
                                case "componentsToFeatures":
                                case "featuresToFeatures":
                                case "modulesToFeatures":
                                    ParseConnectToFeatures(output, reader);
                                    break;
                                case "merge":
                                    ParseMerge(output, reader);
                                    break;
                                case "fileMediaInformation":
                                    output.fileMediaInfoCollection.Add(FileMediaInformation.Parse(reader));
                                    break;
                                case "media":
                                    ParseMedia(output, reader);
                                    break;
                                default:
                                    throw new WixParseException(String.Format("The wixOutput element contains an unexpected child element {0}.", reader.Name));
                            }
                            break;
                        case XmlNodeType.EndElement:
                            done = true;
                            break;
                    }
                }

                if (!done)
                {
                    throw new WixParseException("Missing end element while processing the wixOutput element.");
                }
            }

            return output;
        }

        /// <summary>
        /// Reads all of the component to features entries out of the xml.
        /// </summary>
        /// <param name="output">Output object to add the connection.</param>
        /// <param name="reader">Xml reader.</param>
        private static void ParseConnectToFeatures(Output output, XmlReader reader)
        {
            Debug.Assert("componentsToFeatures" == reader.LocalName || "featuresToFeatures" == reader.LocalName || "modulesToFeatures" == reader.LocalName);

            string elementLocalName = reader.LocalName;
            bool empty = reader.IsEmptyElement;

            if (!empty)
            {
                bool done = false;

                // loop through all the fields in a row
                while (!done && reader.Read())
                {
                    switch (reader.NodeType)
                    {
                        case XmlNodeType.Element:
                            switch (reader.LocalName)
                            {
                                case "connectToFeature":
                                    switch (elementLocalName)
                                    {
                                        case "componentsToFeatures":
                                            output.componentsToFeatures.Add(ConnectToFeature.Parse(reader));
                                            break;
                                        case "featuresToFeatures":
                                            output.featuresToFeatures.Add(ConnectToFeature.Parse(reader));
                                            break;
                                        case "modulesToFeatures":
                                            output.modulesToFeatures.Add(ConnectToFeature.Parse(reader));
                                            break;
                                    }
                                    break;
                                default:
                                    throw new WixParseException(String.Format("The {0} element contains an unexpected child element {1}.", elementLocalName, reader.Name));
                            }
                            break;
                        case XmlNodeType.EndElement:
                            done = true;
                            break;
                    }
                }

                if (!done)
                {
                    throw new WixParseException(String.Format("Missing end element while processing the {0} element.", elementLocalName));
                }
            }
        }

        /// <summary>
        /// Reads a media row entry out of the xml.
        /// </summary>
        /// <param name="output">Output object to add the row.</param>
        /// <param name="reader">Xml reader.</param>
        private static void ParseMerge(Output output, XmlReader reader)
        {
            Debug.Assert("merge" == reader.LocalName);

            TableDefinition mergeTableDefinition = null;
            bool empty = reader.IsEmptyElement;

            if (!empty)
            {
                bool done = false;

                while (!done && reader.Read())
                {
                    switch (reader.NodeType)
                    {
                        case XmlNodeType.Element:
                            switch (reader.LocalName)
                            {
                                case "tableDefinition":
                                    mergeTableDefinition = TableDefinition.Parse(reader);
                                    break;
                                case "tuple":
                                    if (null == mergeTableDefinition)
                                    {
                                        throw new WixParseException("The merge element is missing a tableDefinition child element.");
                                    }
                                    output.modules.Add((MergeRow)Row.Parse(reader, output.entrySection, mergeTableDefinition));
                                    break;
                                default:
                                    throw new WixParseException(String.Format("The merge element contains an unexpected child element {0}.", reader.Name));
                            }
                            break;
                        case XmlNodeType.EndElement:
                            done = true;
                            break;
                    }
                }

                if (!done)
                {
                    throw new WixParseException("Missing end element while processing the merge element.");
                }
            }
        }

        /// <summary>
        /// Reads a media row entry out of the xml.
        /// </summary>
        /// <param name="output">Output object to add the row.</param>
        /// <param name="reader">Reader to get data from.</param>
        private static void ParseMedia(Output output, XmlReader reader)
        {
            Debug.Assert("media" == reader.LocalName);

            TableDefinition mediaTableDefinition = null;
            bool empty = reader.IsEmptyElement;

            if (!empty)
            {
                bool done = false;

                // loop through all the fields in a row
                while (!done && reader.Read())
                {
                    switch (reader.NodeType)
                    {
                        case XmlNodeType.Element:
                        switch (reader.LocalName)
                        {
                            case "tableDefinition":
                                mediaTableDefinition = TableDefinition.Parse(reader);
                                break;
                            case "tuple":
                                if (null == mediaTableDefinition)
                                {
                                    throw new WixParseException("The merge element is missing a tableDefinition child element.");
                                }
                                output.mediaRows.Add((MediaRow)Row.Parse(reader, output.entrySection, mediaTableDefinition));
                                break;
                            default:
                                throw new WixParseException(String.Format("The media element contains an unexpected child element {0}.", reader.Name));
                        }
                            break;
                        case XmlNodeType.EndElement:
                            done = true;
                            break;
                    }
                }

                if (!done)
                {
                    throw new WixParseException("Missing end element while processing the media element.");
                }
            }
        }
    }
}
