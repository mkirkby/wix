//-------------------------------------------------------------------------------------------------
// <copyright file="Output.cs" company="Outercurve Foundation">
//   Copyright (c) 2004, Outercurve Foundation.
//   This software is released under Microsoft Reciprocal License (MS-RL).
//   The license and further copyright text can be found in the file
//   LICENSE.TXT at the root directory of the distribution.
// </copyright>
//-------------------------------------------------------------------------------------------------

namespace WixToolset.Data
{
    using System;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Linq;
    using System.Xml;

    /// <summary>
    /// Output is generated by the linker.
    /// </summary>
    public sealed class Output
    {
        public const string XmlNamespaceUri = "http://wixtoolset.org/schemas/v4/wixout";
        private static readonly Version currentVersion = new Version("4.0.0.0");

        private static readonly object lockObject = new object();

        private Section entrySection;

        private SourceLineNumber sourceLineNumbers;

        private ArrayList subStorages;

        private TempFileCollection tempFileCollection;
        private string cabPath;

        /// <summary>
        /// Creates a new empty output object.
        /// </summary>
        /// <param name="sourceLineNumbers">The source line information for the output.</param>
        public Output(SourceLineNumber sourceLineNumbers)
        {
            this.Sections = new List<Section>();
            this.sourceLineNumbers = sourceLineNumbers;
            this.subStorages = new ArrayList();
            this.Tables = new TableIndexedCollection();
        }

        /// <summary>
        /// Gets the entry section for the output
        /// </summary>
        /// <value>Entry section for the output.</value>
        public Section EntrySection
        {
            get
            {
                return this.entrySection;
            }

            set
            {
                this.entrySection = value;
                this.Codepage = value.Codepage;

                switch (this.entrySection.Type)
                {
                    case SectionType.Bundle:
                        this.Type = OutputType.Bundle;
                        break;
                    case SectionType.Product:
                        this.Type = OutputType.Product;
                        break;
                    case SectionType.Module:
                        this.Type = OutputType.Module;
                        break;
                    case SectionType.PatchCreation:
                        this.Type = OutputType.PatchCreation;
                        break;
                    case SectionType.Patch:
                        this.Type = OutputType.Patch;
                        break;
                    default:
                        throw new InvalidOperationException(String.Format(CultureInfo.CurrentUICulture, WixDataStrings.EXP_UnexpectedEntrySectionType, this.entrySection.Type));
                }
            }
        }

        /// <summary>
        /// Gets the substorages in this output.
        /// </summary>
        /// <value>The substorages in this output.</value>
        public ArrayList SubStorages
        {
            get { return this.subStorages; }
        }

        /// <summary>
        /// Gets the type of the output.
        /// </summary>
        /// <value>Type of the output.</value>
        public OutputType Type { get; set; }

        /// <summary>
        /// Gets or sets the codepage for this output.
        /// </summary>
        /// <value>Codepage of the output.</value>
        public int Codepage { get; set; }

        /// <summary>
        /// Gets the sections contained in the output.
        /// </summary>
        /// <value>Sections in the output.</value>
        public ICollection<Section> Sections { get; private set; }

        /// <summary>
        /// Gets the source line information for this output.
        /// </summary>
        /// <value>The source line information for this output.</value>
        public SourceLineNumber SourceLineNumbers
        {
            get { return this.sourceLineNumbers; }
        }

        /// <summary>
        /// Gets the tables contained in this output.
        /// </summary>
        /// <value>Collection of tables.</value>
        public TableIndexedCollection Tables { get; private set; }

        /// <summary>
        /// Gets the cabPath for that cab that was contained in this output.
        /// </summary>
        /// <value>Path to the extracted cabinet from this output.</value>
        public string CabPath
        {
            get { return this.cabPath; }
        }

        /// <summary>
        /// Gets the output type corresponding to a given output filename extension.
        /// </summary>
        /// <param name="extension">Case-insensitive output filename extension.</param>
        /// <returns>Output type for the extension.</returns>
        public static OutputType GetOutputType(string extension)
        {
            if (String.Equals(extension, ".exe", StringComparison.OrdinalIgnoreCase))
            {
                return OutputType.Bundle;
            }
            if (String.Equals(extension, ".msi", StringComparison.OrdinalIgnoreCase))
            {
                return OutputType.Product;
            }
            else if (String.Equals(extension, ".msm", StringComparison.OrdinalIgnoreCase))
            {
                return OutputType.Module;
            }
            else if (String.Equals(extension, ".msp", StringComparison.OrdinalIgnoreCase))
            {
                return OutputType.Patch;
            }
            else if (String.Equals(extension, ".mst", StringComparison.OrdinalIgnoreCase))
            {
                return OutputType.Transform;
            }
            else if (String.Equals(extension, ".pcp", StringComparison.OrdinalIgnoreCase))
            {
                return OutputType.PatchCreation;
            }
            else
            {
                return OutputType.Unknown;
            }
        }

        /// <summary>
        /// Gets the filename extension corresponding to a given output type.
        /// </summary>
        /// <param name="type">One of the WiX output types.</param>
        /// <returns>Filename extension for the output type, for example ".msi".</returns>
        public static string GetExtension(OutputType type)
        {
            switch (type)
            {
                case OutputType.Bundle:
                    return ".exe";
                case OutputType.Product:
                    return ".msi";
                case OutputType.Module:
                    return ".msm";
                case OutputType.Patch:
                    return ".msp";
                case OutputType.Transform:
                    return ".mst";
                case OutputType.PatchCreation:
                    return ".pcp";
                default:
                    return ".wix";
            }
        }

        /// <summary>
        /// Loads an output from a path on disk.
        /// </summary>
        /// <param name="path">Path to output file saved on disk.</param>
        /// <param name="suppressVersionCheck">Suppresses wix.dll version mismatch check.</param>
        /// <returns>Output object.</returns>
        public static Output Load(string path, bool suppressVersionCheck)
        {
            try
            {
                using (FileStream stream = File.OpenRead(path))
                {
                    return Load(stream, new Uri(Path.GetFullPath(path)), suppressVersionCheck);
                }
            }
            catch (FileNotFoundException)
            {
                throw new WixException(WixDataErrors.WixFileNotFound(path));
            }
        }

        /// <summary>
        /// Saves an output to a path on disk.
        /// </summary>
        /// <param name="path">Path to save output file to on disk.</param>
        /// <param name="tempFilesLocation">Location for temporary files.</param>
        public void Save(string path, string tempFilesLocation)
        {
            FileMode fileMode = FileMode.Create;

            // Assure the location to output the xml exists
            Directory.CreateDirectory(Path.GetDirectoryName(Path.GetFullPath(path)));

            // save the xml
            using (FileStream fs = new FileStream(path, fileMode))
            {
                XmlWriter writer = null;

                try
                {
                    writer = new XmlTextWriter(fs, System.Text.Encoding.UTF8);

                    writer.WriteStartDocument();
                    this.Persist(writer);
                    writer.WriteEndDocument();
                }
                finally
                {
                    if (null != writer)
                    {
                        writer.Close();
                    }
                }
            }
        }

        internal TempFileCollection TempFiles
        {
            get
            {
                return this.tempFileCollection;
            }
            set
            {
                this.tempFileCollection = value;
            }
        }

        /// <summary>
        /// Loads an output from a path on disk.
        /// </summary>
        /// <param name="stream">Stream containing the output file.</param>
        /// <param name="uri">Uri for finding this stream.</param>
        /// <param name="suppressVersionCheck">Suppresses wix.dll version mismatch check.</param>
        /// <returns>Returns the loaded output.</returns>
        /// <remarks>This method will set the Path and SourcePath properties to the appropriate values on successful load.</remarks>
        internal static Output Load(Stream stream, Uri uri, bool suppressVersionCheck)
        {
            XmlReader reader = null;
            TempFileCollection tempFileCollection = null;
            string cabPath = null;

            // look for the Microsoft cabinet file header and save the cabinet data if found
            if ('M' == stream.ReadByte() && 'S' == stream.ReadByte() && 'C' == stream.ReadByte() && 'F' == stream.ReadByte())
            {
                long cabFileSize = 0;
                byte[] offsetBuffer = new byte[4];
                tempFileCollection = new TempFileCollection();
                cabPath = tempFileCollection.AddExtension("cab", false);

                // skip the header checksum
                stream.Seek(4, SeekOrigin.Current);

                // get the cabinet file size
                stream.Read(offsetBuffer, 0, 4);
                cabFileSize = BitConverter.ToInt32(offsetBuffer, 0);

                stream.Seek(0, SeekOrigin.Begin);

                // Create the cab file from stream
                using (FileStream fs = File.Create(cabPath))
                {
                    for (int i = 0; i < cabFileSize; i++)
                    {
                        fs.WriteByte((byte)stream.ReadByte());
                    }
                }
            }
            else // plain xml file - start reading xml at the beginning of the stream
            {
                stream.Seek(0, SeekOrigin.Begin);
            }

            // read the xml
            try
            {
                reader = new XmlTextReader(uri.AbsoluteUri, stream);

                reader.MoveToContent();

                if ("wixOutput" != reader.LocalName)
                {
                    throw new WixNotOutputException(WixDataErrors.InvalidDocumentElement(SourceLineNumber.CreateFromUri(reader.BaseURI), reader.Name, "output", "wixOutput"));
                }

                Output output = Parse(reader, suppressVersionCheck);
                output.tempFileCollection = tempFileCollection;
                output.cabPath = cabPath;

                return output;
            }
            catch (XmlException xe)
            {
                throw new WixException(WixDataErrors.InvalidXml(SourceLineNumber.CreateFromUri(reader.BaseURI), "output", xe.Message));
            }
            finally
            {
                if (null != reader)
                {
                    reader.Close();
                }
            }
        }

        /// <summary>
        /// Processes an XmlReader and builds up the output object.
        /// </summary>
        /// <param name="reader">Reader to get data from.</param>
        /// <param name="suppressVersionCheck">Suppresses wix.dll version mismatch check.</param>
        /// <returns>The Output represented by the Xml.</returns>
        internal static Output Parse(XmlReader reader, bool suppressVersionCheck)
        {
            Debug.Assert("wixOutput" == reader.LocalName);

            bool empty = reader.IsEmptyElement;
            Output output = new Output(SourceLineNumber.CreateFromUri(reader.BaseURI));
            SectionType sectionType = SectionType.Unknown;
            Version version = null;

            while (reader.MoveToNextAttribute())
            {
                switch (reader.LocalName)
                {
                    case "codepage":
                        output.Codepage = Convert.ToInt32(reader.Value, CultureInfo.InvariantCulture.NumberFormat);
                        break;
                    case "type":
                        switch (reader.Value)
                        {
                            case "Bundle":
                                output.Type = OutputType.Bundle;
                                sectionType = SectionType.Bundle;
                                break;
                            case "Module":
                                output.Type = OutputType.Module;
                                sectionType = SectionType.Module;
                                break;
                            case "Patch":
                                output.Type = OutputType.Patch;
                                break;
                            case "PatchCreation":
                                output.Type = OutputType.PatchCreation;
                                sectionType = SectionType.PatchCreation;
                                break;
                            case "Product":
                                output.Type = OutputType.Product;
                                sectionType = SectionType.Product;
                                break;
                            case "Transform":
                                output.Type = OutputType.Transform;
                                break;
                            default:
                                throw new WixException(WixDataErrors.IllegalAttributeValue(SourceLineNumber.CreateFromUri(reader.BaseURI), "wixOutput", reader.Name, reader.Value, "Module", "Patch", "PatchCreation", "Product", "Transform"));
                        }
                        break;
                    case "version":
                        version = new Version(reader.Value);
                        break;
                    default:
                        if (!reader.NamespaceURI.StartsWith("http://www.w3.org/", StringComparison.Ordinal))
                        {
                            throw new WixException(WixDataErrors.UnexpectedAttribute(SourceLineNumber.CreateFromUri(reader.BaseURI), "wixOutput", reader.Name));
                        }
                        break;
                }
            }

            if (null != version && !suppressVersionCheck)
            {
                if (0 != currentVersion.CompareTo(version))
                {
                    throw new WixException(WixDataErrors.VersionMismatch(SourceLineNumber.CreateFromUri(reader.BaseURI), "wixOutput", version.ToString(), currentVersion.ToString()));
                }
            }

            // create a section for all the rows to belong to
            output.entrySection = new Section(null, sectionType, output.Codepage);

            // loop through the rest of the xml building up the Output object
            TableDefinitionCollection tableDefinitions = null;
            List<Table> tables = new List<Table>();
            if (!empty)
            {
                bool done = false;

                // loop through all the fields in a row
                while (!done && reader.Read())
                {
                    switch (reader.NodeType)
                    {
                        case XmlNodeType.Element:
                            switch (reader.LocalName)
                            {
                                case "subStorage":
                                    output.SubStorages.Add(SubStorage.Parse(reader));
                                    break;
                                case "table":
                                    if (null == tableDefinitions)
                                    {
                                        throw new WixException(WixDataErrors.ExpectedElement(SourceLineNumber.CreateFromUri(reader.BaseURI), "wixOutput", "tableDefinitions"));
                                    }
                                    tables.Add(Table.Read(reader, output.entrySection, tableDefinitions));
                                    break;
                                case "tableDefinitions":
                                    tableDefinitions = TableDefinitionCollection.Parse(reader);
                                    break;
                                default:
                                    throw new WixException(WixDataErrors.UnexpectedElement(SourceLineNumber.CreateFromUri(reader.BaseURI), "wixOutput", reader.Name));
                            }
                            break;
                        case XmlNodeType.EndElement:
                            done = true;
                            break;
                    }
                }

                if (!done)
                {
                    throw new WixException(WixDataErrors.ExpectedEndElement(SourceLineNumber.CreateFromUri(reader.BaseURI), "wixOutput"));
                }
            }

            output.Tables = new TableIndexedCollection(tables);
            return output;
        }

        /// <summary>
        /// Ensure this output contains a particular table.
        /// </summary>
        /// <param name="tableDefinition">Definition of the table that should exist.</param>
        /// <param name="section">Optional section to use for the table. If one is not provided, the entry section will be used.</param>
        /// <returns>The table in this output.</returns>
        public Table EnsureTable(TableDefinition tableDefinition, Section section = null)
        {
            Table table;
            if (!this.Tables.TryGetTable(tableDefinition.Name, out table))
            {
                table = new Table(section ?? this.entrySection, tableDefinition);
                this.Tables.Add(table);
            }

            return table;
        }

        /// <summary>
        /// Persists an output in an XML format.
        /// </summary>
        /// <param name="writer">XmlWriter where the Output should persist itself as XML.</param>
        internal void Persist(XmlWriter writer)
        {
            writer.WriteStartElement("wixOutput", XmlNamespaceUri);

            writer.WriteAttributeString("type", this.Type.ToString());

            if (0 != this.Codepage)
            {
                writer.WriteAttributeString("codepage", this.Codepage.ToString(CultureInfo.InvariantCulture));
            }

            writer.WriteAttributeString("version", currentVersion.ToString());

            // collect all the table defintitions and write them
            TableDefinitionCollection tableDefinitions = new TableDefinitionCollection();
            foreach (Table table in this.Tables.OrderBy(t => t.Name))
            {
                tableDefinitions.Add(table.Definition);
            }
            tableDefinitions.Persist(writer);

            foreach (Table table in this.Tables.OrderBy(t => t.Name))
            {
                table.Write(writer);
            }

            foreach (SubStorage subStorage in this.subStorages)
            {
                subStorage.Persist(writer);
            }

            writer.WriteEndElement();
        }
    }
}
